import pandas as pd
from datetime import timedelta

class StrategyAgent:
    """
    StrategyAgent applies trading rules to forecast signals generated by a forecast agent.

    Workflow:
      1. Uses provided forecast agent to produce 'forecast_signals' DataFrame from features
      2. Applies minimum holding period and max trades per week rules to signals

    Rules enforced:
      - Minimum holding period between trades (in days)
      - Maximum number of trades per rolling 7-day window
    """

    def __init__(
        self,
        forecast_agent,
        min_holding_period: int = 5,
        max_trades_per_week: int = 3
    ):
        """
        Args:
            forecast_agent: An object with a predict(feature_df, sentiment_df) method
            min_holding_period: Days to hold a position before new trade
            max_trades_per_week: Max trades in any rolling 7-day window
        """
        # Ensure forecast_agent has predict method
        if not callable(getattr(forecast_agent, 'predict', None)):
            raise ValueError("forecast_agent must have a callable predict(feature_df, sentiment_df) method")
        self.forecast_agent = forecast_agent
        self.min_holding = pd.Timedelta(days=min_holding_period)
        self.max_trades = max_trades_per_week

    def generate_orders(
        self,
        feature_df: pd.DataFrame,
        sentiment_df: pd.DataFrame,
        price_df: pd.DataFrame
    ) -> pd.DataFrame:
        """
        Generate trade orders based on forecast signals.

        Args:
            feature_df: DataFrame of features for forecasting
            sentiment_df: DataFrame of sentiment scores
            price_df: DataFrame with 'Close' prices

        Returns:
            DataFrame indexed by date with columns ['signal','order','price']
        """
        # Step 1: Forecast signals
        forecast_signals = self.forecast_agent.predict(feature_df, sentiment_df)
        if 'signal' not in forecast_signals.columns:
            raise ValueError("Forecast agent must return DataFrame with 'signal' column")

        # Step 2: Align signals and prices
        df = forecast_signals[['signal']].rename(columns={'signal':'combined_signal'})
        df = df.join(price_df[['Close']], how='left').sort_index()
        df['order'] = 0

        # Step 3: Apply strategy rules
        last_trade = None
        trades = []
        for ts, row in df.iterrows():
            sig = row['combined_signal']
            if sig == 0:
                continue
            # Minimum holding period
            if last_trade and ts - last_trade < self.min_holding:
                continue
            # Maximum trades in past 7 days
            window_start = ts - timedelta(days=7)
            recent = [t for t in trades if t >= window_start]
            if len(recent) >= self.max_trades:
                continue
            df.at[ts, 'order'] = sig
            last_trade = ts
            trades.append(ts)

        return df[['combined_signal', 'order', 'Close']].rename(columns={'Close':'price'})

if __name__ == '__main__':
    # Dummy forecast agent for testing
    class DummyForecast:
        def predict(self, feature_df, sentiment_df):
            import numpy as np
            idx = feature_df.index
            sigs = np.tile([1, 0, -1], int(len(idx)/3)+1)[:len(idx)]
            return pd.DataFrame({'signal': sigs}, index=idx)

    # Create synthetic price series
    import numpy as np
    from pandas import date_range
    dates = date_range('2025-01-01', periods=30, freq='D')
    price_df = pd.DataFrame({'Close': 100 + np.cumsum(np.random.randn(len(dates)))}, index=dates)
    # Synthetic features and sentiment (unused by DummyForecast)
    feature_df = pd.DataFrame(index=dates)
    sentiment_df = pd.DataFrame(index=dates)

    dummy_forecast = DummyForecast()
    strat = StrategyAgent(forecast_agent=dummy_forecast, min_holding_period=3, max_trades_per_week=2)
    orders = strat.generate_orders(feature_df, sentiment_df, price_df)
    print(orders[orders['order'] != 0])
